/**
 *
 * Data Stream Median
 *
 * Numbers keep coming, return the median of numbers at every time a new number added.
 *
 * Example:
 * For numbers coming list: [1, 2, 3, 4, 5], return [1, 1, 2, 2, 3].
 *
 * For numbers coming list: [4, 5, 1, 3, 2, 6, 0], return [4, 4, 4, 3, 3, 3, 3].
 *
 * For numbers coming list: [2, 20, 100], return [2, 2, 20].
 */
 public class Solution {
    /**
     * @param nums: A list of integers.
     * @return: the median of numbers
     */
    public int[] medianII(int[] nums) {

        // corner cause
       if (nums == null || nums.length == 0) {
           return new int[0];
       }

       int length = nums.length;
       int[] result = new int[length];

       // initialize a maxHeap for the numbers less than the median
       PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(length / 2 + 1, Collections.reverseOrder());
       // initialize a minHeap for the numbers larger than the median
       PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>(length / 2 + 1);
       // initialize the median as the first incoming element
       int median = nums[0];
       // add the median to the result array
       result[0] = median;

       for (int i = 1; i < nums.length; i++) {

           // add the incoming number to the appropriate heap first
           if (nums[i] >= median) {
               minHeap.offer(nums[i]);
           } else {
               maxHeap.offer(nums[i]);
           }

           // compare the sizes of the two heap and shift numbers
           if (maxHeap.size() > minHeap.size()) {
               minHeap.offer(median);
               median = maxHeap.poll();
           }

           if ((minHeap.size() - maxHeap.size()) > 1) {
               maxHeap.offer(median);
               median = minHeap.poll();
           }

           result[i] = median;

       }

       return result;
    }
}
